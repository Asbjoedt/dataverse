name: "Get Incremented Revision Tag"
description: "For a pre-existing rolling tag lookup the latest immutable revision tag, increment and return"
inputs:
  image-ref:
    description: "The full image reference including namespace, repo and tag"
    required: true
  revision-separator:
    description: "The separator string to use between tag and revision number. Defaults to '-r'"
    required: false
    default: "-r"
  tag-options-prefix:
    description: "A string that the revision tag will be appended to and sent to output tag-options"
    required: false
    default: ""
outputs:
  revision-tag:
    description: "The updated immutable tag, ready to use"
    value: ${{ steps.extract.outputs.revision_tag }}
  tag-options:
    description: "A string with some command line options (may be empty)"
    value: ${{ steps.extract.outputs.tag_options }}
runs:
  using: composite
  steps:
    - shell: bash
      id: extract
      run: |
        IMAGE="${{ inputs.image-ref }}"
        IMAGE_NS_REPO="${IMAGE%:*}"
        IMAGE_TAG="${IMAGE#*:}"

        if [[ "$IMAGE_TAG" = "$IMAGE_NS_REPO" ]]; then
          >&2 echo "You must provide an image reference in the format [<namespace>/]<repo>:<tag>"
          exit 1
        fi

        case "$IMAGE_NS_REPO" in
            */*) :;; # namespace/repository syntax, leave as is
            *) IMAGE_NS_REPO="library/$IMAGE_NS_REPO";; # bare repository name (docker official image); must convert to namespace/repository syntax
        esac

        # Without such a token we run into rate limits
        token=$( curl -s "https://auth.docker.io/token?service=registry.docker.io&scope=repository:$IMAGE_NS_REPO:pull" )

        ALL_TAGS="$(
          i=0
          while [ $? == 0 ]; do
              i=$((i+1))
              RESULT=$( curl -s -H "Authorization: Bearer $token" "https://registry.hub.docker.com/v2/repositories/$IMAGE_NS_REPO/tags/?page=$i&page_size=100" )
              if [[ $( echo "$RESULT" | jq '.message' ) != "null" ]]; then
                # If we run into an error on the first attempt, that means we have a problem.
                if [[ "$i" == "1" ]]; then
                  >&2 echo "Error when retrieving tag data: $( echo "$RESULT" | jq '.message' )"
                  exit 2
                # Otherwise it will just mean we reached the last page already
                else
                  break
                fi
              else
                echo "$RESULT" | jq -r '."results"[]["name"]'
                # DEBUG:
                #echo "$RESULT" | >&2 jq -r '."results"[]["name"]'
              fi
          done
        )"

        # Note: if a former tag could not be found, it just might not exist already. Start new series with rev 0
        CURRENT=$( echo "$ALL_TAGS" | grep "${IMAGE_TAG}${{ inputs.revision-separator }}" | sed -e "s#${IMAGE_TAG}${{ inputs.revision-separator }}##" | sort -h | tail -n1 )
        if [[ "$CURRENT" ]]; then
          REVISION_TAG="${IMAGE_TAG}${{ inputs.revision-separator }}$((CURRENT+1))"
        else
          REVISION_TAG="${IMAGE_TAG}${{ inputs.revision-separator }}0" 
        fi
        echo "revision_tag=${REVISION_TAG}" | tee -a "$GITHUB_OUTPUT"
        
        if [[ -n "${{ inputs.tag-options-prefix }}" ]]; then
          echo "tag_options=${{ inputs.tag-options-prefix }}${REVISION_TAG}" | tee -a "$GITHUB_OUTPUT" 
        fi